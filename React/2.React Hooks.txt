Re-render/Mounted & Unmounted
- Re-render: render lại component (khi 1 state sử dụng trong component đó thay đổi) => dẫn đến render cả các component child trong nó
- Mounted: render ra component mới khi so khớp với 1 state trong JSX của parent component
   : render ra parent, gắn child vào parent là mounted, mounted xong mới render child tiếp trong parent 
   : việc component xuất hiện trong JSX
- Unmounted: hủy render component mới trong parent component
   : component biến mất khỏi JSX
////////////////////////////////////////////////
Ex: JSX mounted trong function component

import React, { useState } from 'react';
import ChildComponent from './ChildComponent';

const ParentComponent = () => {
  const [state, setState] = useState(false);

  return (
    <div>
       <button onClick={() => setState(!state)}>Toggle</button>
       {show && <ChildComponent />}
    </div>
  );
};

export default ParentComponent;
================================================================================================
USE-STATE=======================================================================================
useState() : khi muốn re-render giao diện mỗi khi dữ liệu thay đổi (thao tác state)
const [state, setState] = useState(initState);
-useState() tạo ra 1 state (biến mà react theo dõi sự thay đổi của nó để render giao diện)
  -initState truyền vào là giá trị đầu tiên muốn gán cho state
  -initState có thể nhận vào 1 callbackfn và nhận giá trị mà callback đó trả về để khởi tạo state (state không nhận là 1 function mà nhận giá trị cả function đó): sử dụng khi muốn đưa 1 tính toán phức tạp trong 1 function để khởi tạo state thay vì tính toán function ở bên ngoài và sẽ luôn thực thi tính toán lại mỗi khi re-render component
-useState() trả về 1 mảng gồm 2 phần tử
  -state muốn khởi tạo, lần đầu khởi tạo mang giá trị === initState  
  -setState: function giúp thay đổi giá trị của state
    setState(_value) : đưa giá trị state muốn thay đổi vào làm tham số, gọi liên tiếp setState() trong 1 lần render sẽ chỉ có 1 giá trị state được lưu từ lần render trước, state chỉ thay đổi 1 lần trong 1 lần
    setState(preState => { return _value })  : đưa vào 1 funtion vào làm tham số, funtion này tham chiếu đến giá trị state trước đó được setState(), đảm bảo luôn setState lần lượt dựa vào giá trị của state trước (trong cùng 1 lần render)
      => gọi setState() liên tiếp trong 1 lần render đảm bảo giá trị state thực thi thay đổi lần lượt sau mỗi lần gọi

*Two-way binding ràng buộc 2 chiều, làm việc với form
  -One-way binding (React): sửa dữ liệu trên giao diện giúp thay đổi state
-Two-way binding đảm bảo khi sửa dữ liệu giao diện hay sửa đổi state sẽ thay đổi cả bên còn lại
////////////////////////////////////////////////
- INPUT TEXT 
    component fn:  
      const [inputValue, setInputValue] = useState('');// khởi tạo state bằng chuỗi rỗng
      JSX: 
        input type="text": 
          prop: value={inputValue} onChange={e => setInputValue(e.target.value)}
- INPUT RADIO
    const datas = [{id: 1, name: 'A'}, {id: 2, name: 'B'}];
    component fn:  
      const [checkedValue, setCheckedValue] = useState();
      // khởi tạo state bằng undefined == không check
      JSX:
        {datas.map(data => (
          <div key={data.id}>
            <input
              type="radio"
              checked={checkedValue === data.id}
              onChange={() => setCheckedValue(data.id)}
             >
          </div>   
         ))}
- INPUT CHECKBOX
    const datas = [{id: 1, name: 'A'}, {id: 2, name: 'B'}];
    component fn:  
      const [checkedValue, setCheckedValue] = useState([]);
      // khởi tạo state bằng mảng rỗng
      const handleCheck = (id) => {
        setCheckedValue(preState => {
          if(checkedValue.includes(id)) {
            return preState.filter(item => item != id);
          }           
          return [...preState, id];
        })
      }
      JSX:
        {datas.map(data => (
          <div key={data.id}>
            <input
              type="checkbox"
              checked={checkedValue.includes(data.id)}
              onChange={() => handleCheck(data.id)}
             >
          </div>   
         ))}
================================================================================================
USE-EFFECT======================================================================================
useEffect(): sử dụng khi thao tác với state, với props để render giao diện phụ thuộc vào các dependencies đính kèm, thay thế cho useState khi call API, update DOM: scroll/ resize, listen DOM event, clean up (remove listener/unsubscribe, clear timer)
userEffect(() => { ... }, [ dependencies ]);

-Nhận vào 2 arguments:
  1: callback fn thực thi logic phụ thuộc vào sự thay đổi của các dependencies 
  2: mảng các dependencies để useEffect theo dõi thực thi callback fn: các props hoặc các state
-Callback LUÔN LUÔN được gọi ngay sau khi component chứa useEffect() MOUNTED
-Mảng dependencies không bắt buộc khi đưa vào useEffect(), là 
  TH1: useEffect(callbackfn) : Sử dụng update DOM (document.title)  không addEvent, tránh setState() trong TH này
   -Callback luôn luôn được gọi mỗi khi component re-render (thay đổi state)
   -Code ngoài useEffect sẽ thực thi trước (JSX trước) rồi mới thực thi callbackfn (:re-render trước mounted)
   -Do callback thực thi SAU khi re-render => đảm bảo giao diện đã render trước khi mounted => tránh khi thực thi logic nặng trước khi render (thực thi logic không sử dụng useEffect() => thực thi logic trước mới render)
  TH2: useEffect(callbackfn, []) : Sử dụng call API, addEvent, setTimmer, khi setState() trong useEffect() nhưng không muốn re-render vô hạn lần
   -Sử dụng call API ngay ngoài useEffect hoặc useEffect không đi kèm argument thứ 2 và đưa data lên giao diện bằng setState(data) 
     => giao diện sẽ re-render khi thực thi lấy được data: setState(data) 
     => mỗi lần re-render sẽ thực thi lại việc call API => tạo vòng lặp call API vô hạn
   -Đưa vào useEffect argument thứ 2 là 1 mảng rỗng: [] 
     => chỉ gọi callbackfn 1 lần duy nhất sau khi component được mounted 
     => nếu setState() trong useEffect() có [], tổng thể component fn vẫn thực thi 2 lần, lần đầu render ra component, thực thi callback trong useEffect (có setState()) => render lại component (thực thi lại component fn) không thực thi lại callback trong useEffect()
   -AddEvent trong useEffect() => thực thi 1 callback trong callback của useEffect 
     => setState() trong callback của addEventListener() 
     => dẫn đến việc liên tục setState() khi event đó được kích hoạt, tổng thể useEffect vẫn chỉ gọi 1 lần khi lần mounted đầu tiên, chỉ có duy nhất 1 hàm addEvent
     => callback của event sẽ set lại state, render lại toàn bộ component ngoại trừ hàm useEffect
   -SetInterval trong useEffect() 
     => thao tác setState trong callback của setInterval trong callback của useEffect => setInterval vẫn chỉ gọi duy nhất 1 lần lúc component mounted
     => do không có deps, khi setInterval thực thi setState liên tục, tuy nhiên không thực thi lại code trong useEffect => state luôn mang 1 giá trị được khởi tạo ban đầu do tính chất closure (vì useEffect sử dụng state 1 lần đầu tiên lúc mounted) 
     => thao tác với state trong setInterval lại thao tác với chính state ban đầu (mất tính liên tục của setInterval)
     => C1: đưa funtion thao tác với prestate vào setState() để thao tác với state trước đó:
        setState(preState => {...}); đảm bảo mỗi khi setState lại sẽ thao tác với state trước đó đã được setState()
     => C2: thay setInterval = setTimeOut và đưa state vào làm 1 deps trong mảng deps của useEffect => setTimeout liên tục được gọi khi state nó thao tác bị thay đổi => thực thi liên tục useEffect => tham chiếu liên tục đến state ở bên ngoài được set lại do setTimeout mỗi lần thực thi useEffect 
     
  TH3: useEffect(callbackfn, [dependencies]) : Sử dụng khi thay đổi state ở ngoài useEffect() và theo dõi state đó để thực thi callbackfn => đưa state vào mảng dependencies
   -Callback fn được gọi lại mỗi khi dependency thay đổi (lần đầu tiên khi mouted vẫn thực thi callback)
   -setState() trong useEffect ở trường hợp này mà không đưa state đã set vào mảng dependencies
     => việc setState() sẽ không tạo thành vòng lặp giống TH2, chỉ setState 1 lần sau khi mouted hoặc sau khi bất cứ dependencies nào thay đổi

-callbackfn cho return lại 1 funtion, function này thực thi trước bất cứ khi nào component unmounted hoặc trước khi callback trong useEffect() được thực thi lại
  - State trong return function này là state của lần gọi callback trước
  - Khi addEventListener với callback sử dụng setState
    => sử dụng trong useEffect với [] giúp không liên tục addEvent khi trong callback của event đó có thực thi setState để render lại giao diện (tránh chạy lại componnet fn liên tục)
    => remove event khi return lại funcion trong callbackfn của useEffect() => khi unmound component đồng thời xóa đi event đã add vào component đó tránh rò rỉ bộ nhớ 
  - Khi sử dụng các timmer function có callback sử dụng setState
    => sử dụng trong useEffect với [] giúp không thêm liên tục các timmer fn 
    => remove timmer khi return lại funtion trong callback của useEffect => khi unmound component đồng thời xóa đi timmer đó để tránh rò rỉ bộ nhớ
  - Sử dụng URL.createObjectURL(file): tạo url lấy ra file đó, sử dụng url để preview img
    => luôn tạo bộ nhớ mới chứa ảnh trong url được tạo ra
    => thay đổi file theo dõi bằng onChange ở JSX => thực thi tạo URL mới, URL cũ vẫn trong bộ nhớ => rò rỉ bộ nhớ
    => sử dụng return trong callback của useEffect() thực hiện:   URL.revokeObjectURL(file) 
     
*useLayoutEffect() thực thi code trong callback trước khi render (sync)
 => sử dụng khi setState ngoài useLayoutEffect vầ lại dùng useLayoutEffect theo dõi state đó, kiểm tra state và set lại nếu setState ở ngoài bị lỗi => (UI) không render lại giao diện 2 lần liền như useEffect() (async)

================================================================================================
USE-REF=========================================================================================
useRef(): tạo ra 1 object trong component fn không được khởi tạo lại mỗi khi re-render
 => object trỏ đến cùng 1 địa chỉ khi mỗi lần re-render
 ~~ tạo biến ngoài phạm vi component fn 
const refObj = useRef(_initValue);
 _initValue là gì trị khởi tạo của refObj.current khi lần đầu mounted, nếu không đưa gì vào useRef() => giá trị khởi tạo bằng undefined
-useRef() luôn trả về 1 object, object có 1 property duy nhất là current
  giá trị của refObj.current là _initValue trong lần mounted đầu tiên
-Sử dụng refObj.current để lưu biến ngoài phạm vi của các handlerEvent, giúp biến luôn trỏ đến 1 vùng nhớ (không khởi tạo lại biến) khi re-render giao diện 
  => thao tác sửa đổi biến ở nhiều handlerEvent khác nhau (mỗi handlerEvent thực thi đồng thời re-render giao diện và đặt giá trị mới cho biến useRef đó) => luôn lưu giá trị cũ mỗi lần re-render
////////////////////////////////////////////////////////////
-Sử dụng useRef để lưu 1 state trước của lần render trước
  const [state, setState] = useState(60);
  const prevState = useRef()
  
  useEffect(() => {
    prevState.current = state;
    // callback này được thực thi sau render 
    // => sau dòng này prevState.current đã bằng state hiện tại
  }, [state]);
  
  const handleStart = {
    setInterval(() => {
      setState(prev => prev - 1);
    }, 1000)
  }

  console.log(prevState.current, state);
  // callback trong useEffect thực thi  sau render JSX 
  //=> tại đây prevState.current = state trước
 
  return (
    <div> 
      <h1>{state}</h1>
      <button onClick={handleStart}>Start</button> 
    </div>
  )

-Sử dụng useRef lưu DOMElement bằng cách đặt prop ref={refObject} vào element cần lưu, không sử dụng được với ComponentElement
  -Thao tác sửa DOM trực tiếp trên biến refObject.current
  -Lấy value của Input ELement: refObject.current.value thay thế sử dụng useState() để onChange
  -Lấy object tạo độ Element: refObject.current.getBoundingClientRect()
  -Khi có tình huống update lại DOM element đã ref => refObject luôn được update theo

-Sử dụng useRef() với ComponentElement: (React không cho truyền prop ref từ parent component sang child component)
  - tạo refObj ở parent component
  - gán refObj cũng bằng prop ref tại component child trong JSX của parent component
  - tại child component fn, bao bọc component này bằng React.forwardRef()
  - component fn child cho nhận thêm 1 tham số thứ 2 là ref, ref chính là object truyền vào prop ref ở JSX của parent component
  - gán ref này bằng prop ref 1 lần nữa tại chính xác DOMElement muốn lưu trong JSX của child component fn 
  => giúp lưu DOM element của child component, thao tác với DOM element đó tại parent element
  
================================================================================================
USE-REDUCER=====================================================================================
useReducer()
-Giúp quản lý state giống useState()
-Sử dụng hữu ích trong các trường hợp phức tạp hơn, sử dụng thay useState khi có các state phụ thuộc vào nhau, state này cập nhật dựa trên sự cập nhật của state khác, state có nhiều object, nhiều mảng con bên trong

const [state, dispatchFn] = useReducer(reducerFn, initialState, initFn);
- reducerFn: funtion thực thi thay đổi state
  const reducer = (state, dispatchValue) => {... return _newState }
    - reducerFn nhận vào state hiện tại và 1 dispatchValue (giá trị truyền vào dispatchFn)
    - dựa trên giá trị truyền vào của dispatchFn, reducerFn sẽ trả về giá trị mới cho state
- initialState: giá trị khởi tạo cho state khi component lần đầu được mounted
- initFn: là function sẽ nhận vào initialState và thay đổi trả lại state cho lần mounted đầu tiên
- dispatchFn: nhận vào 1 giá trị, giá trị này được truyền qua cho reducerFn, gọi reducerFn thực thi trả về 1 state mới
- thường không cần sử dụng initFn đưa vào useReducer()
/////////////////////////////////////////////////////////////////////
Ex:
const emailReducer = (state, action) => {
  if (action.type === 'USER_INPUT') {
    return { value: action.val, isValid: action.val.includes('@') };
  }
  if (action.type === 'INPUT_BLUR') {
    return { value: state.value, isValid: state.value.includes('@') };
  }
  return { value: '', isValid: false };
};

const Component (props) => {
  const [emailState, dispatchEmail] = useReducer(emailReducer, {
    value: '',
    isValid: null,
  });
  const [formIsValid, setFormIsValid] = useState(false);

  const emailChangeHandler = (event) => {
    dispatchEmail({type: 'USER_INPUT', val: event.target.value});

    setFormIsValid(
      event.target.value.includes('@');
    );
  };

  const validateEmailHandler = () => {
    dispatchEmail({type: 'INPUT_BLUR'});
  };

  const submitHandler = (event) => {
    event.preventDefault();
    props.onLogin(emailState.value);
  };

  return (
    <Card className={classes.login}>
      <form onSubmit={submitHandler}>
        <div
          className={`${classes.control} ${
            emailState.isValid === false ? classes.invalid : ''
          }`}
        >
          <label htmlFor="email">E-Mail</label>
          <input
            type="email"
            id="email"
            value={emailState.value}
            onChange={emailChangeHandler}
            onBlur={validateEmailHandler}
          />
        </div>
        <Button type="submit" className={classes.btn} disabled={!formIsValid}>
          Login
        </Button>
      </form>
    </Card>
  );
};

export default Component
================================================================================================
USE-CALLBACK====================================================================================
useCallback() - React.memo() 
-Tránh TẠO RA các function MỚI không kiểm soát trong fn component khiến cho component re-render không kiểm soát dừ đã áp dụng React.memo()
  -đưa handleChangeState của parent vào component child => dẫn đến tiếp tục re-render component child mỗi lần có event thực thi handleChangeState mặc dù đã wrap component child bởi React.memo()
    => do đưa 1 function là prop truyền vào component child, funtion, object, array là kiểu reference types => khi so sánh giữa prop của lần render trước với hiện tại không so sánh trực tiếp funtion mà so sánh tham chiếu đến nó, mỗi lần re-render parent lại tạo ra 1 funtion với tham chiếu mới rồi gán với child => '===' trả về false => tiếp tục render component child

const handle = useCallback(callbackfn, []);
  -callbackfn được đưa vào useCallback(), useCallback sẽ trả về tham chiếu của function đó lưu ra bên ngoài component và trả về biến handle 
   => biến handle sẽ lưu giá trị tham chiếu ở mọi lần remder => giá trị của prop là fn sẽ không thay đổi khi đưa handle vào => không re-render lại component child
  -[] là 1 mảng các dependencies, useCallback() sẽ theo dõi sự thay đổi của từng dep trong mảng deps để tạo 1 fntion mởi, trả về tham chiếu mới
    => tương tự useEffect, với 1 mảng deps rỗng: [], useCallback() chỉ thực thi lần đầu khi mounted component

================================================================================================
USE-MEMO========================================================================================
useMemo()
-Tránh THỰC THI lại 1 function trong component fn mỗi khi re-render component, thay vì chỉ cần function thực thi khi thực hiện 1 event nhất định trong component

const result = useMemo(callbackfn, []);
  - giống useCallback() hoặc useEffect(), useMemo() nhận vào 1 callbackfn và thực thi fn đó mỗi khi 1 trong các dep thay đổi
  - mảng deps rỗng: [], useMemo chỉ thực hiện lần đầu tiên khi được mounted
  - thường đưa các tham số cần truyền vào callbackfn làm các deps

================================================================================================
USE-CONTEXT=====================================================================================
useContext() 
- đơn giản hóa việc đưa dữ liệu qua các component, không cần truyền dữ liệu gián tiếp qua props 
của component trung gian

-const Context = React.creatContext();
  - React.creatContext() tạo ra 1 context, cho phép lưu trữ data, thường dùng để lưu state để truyền qua các componet
    - React.creatContext() có thể nhận vào 1 giá trị default, thường đưa vào 1 object gồm các properties là các state cần được lưu trữ hỗ trợ vscode gợi ý code, giá trị default ban đầu có thể truy xuất ở trong Context.Consumer
  - Context : được trả về bởi React.creatContext(), trong đó:
     - Context.Provider : là 1 react component sử dụng trong component cha để wrap lấy nhóm các component cần truyền các giá trị được lưu trong Context
       - giá trị trong context sẽ truyền qua được các component child, child của child, ...
       - giá trị ban đầu được khởi tạo là giá trị default đưa vào React.creatContext(), để lưu state cần truyền vào trong các component bọc bởi Context.Provider, sử dụng prop: value={state} trong Context.Provider
          <Context.Provider value={state}>
            <ComponentA>
            <ComponentB>
            <ComponentC>
          </Context.Provider>
     - Context.Consumer : là 1 react component sử dụng trong mã JSX của component cần nhận dữ liệu trong context, wrap 1 chuỗi code JS nhận dữ liệu trả về JSX
       - giá trị Context.Consumer nhận được là giá trị được đưa vào prop value của Context.Provider, nếu các parent component của component (có JSX được bọc bởi Context.Consumer)
không sử dụng Context.Provider thì giá trị nó nhận được là giá trị default đưa vào React.creatContext()
       - sử dụng giá trị context nhận được bằng cách:         
         <Context.Consumer>{(ctx) => { return JSX; }</Context.Consumer>

- sử dụng useContext() thay thế cho Context.Consumer
  const ctx = useContext(_nameContext);
    _nameContext là tên gái trị trả về của React.creatContext()
    ctx: chứa dữ liệu được đưa vào prop value của Context.Provider hoặc giá trị default của React.creatContext()
  - sử dụng useContext không tối ứu cho việc thay đổi state quá nhiều => việc giử state giữa các component chỉ qua 1 hoặc 2 component trung gian vẫn ưu tiên sử dụng props , hoặc thay thế hẳn bằng redux
///////////////////////////////////////////////////////////////
Ex: tạo global state
/* src/store/Context.js */
  import React, { useState, useContext } from 'react';
  
  export Context = React.createContext();
  
  export Provider = (props) => {
    const [state, setState] = useState(true);
    
    handleState = (state) => {
      return !state;
    }
    const value = {
      state,
      handleState
    }
   
    return (
      <Context.Provider value={value}>
        {props.children}
      </Context.Provider>
    ) 
  }

/* src/index.js */
  import { Provider } from './store/Context.js';
  
  ....
  
  ReactDOM.render(
    <Provider>
      <App />
    </Provider>, 
    document.getElementById('root')
  );

  .... 

/* src/App.js */
  import ComponentA from './component/ComponentA';
  ...
  return (<><ComponentA></>);
  ...
/* src/component/ComponentA.js  */
  import { useContext } from 'react';
  import { Context } from '.././store/Context.js';

  const ComponentA = () => {
    const ctx = useContext(Context);
    
    return { 
      <div>
        <button onClick={ctx.handleState}>{ctx.state ? 'On' : 'Off'}</button>
      </div> 
    };    
  }
  

================================================================================================
USE-IMPERATIVAHANDLE============================================================================
useImperativeHandle(): giúp tùy chỉnh ref của 1 funtion component
-Thao tác đi cùng với useRef() và React.forwardRef()
-Sử dụng React.forwardRef(), cùng useRef()

////////////////////////////////
    ParentComponent:
      const refComponent = useRef();
      // thao tác với refComponent.current để sửa đổi element trong ChildComponen
      JSX: 
       <ChildComponent ref={refComponent} />
   
    ChildComponent:
      const ChildComponent = React.forwardRef((props, ref) => {
        return (
          <h1 ref={ref}>Hello</h1>
        )
      })

-Nếu chỉ sử dụng .forwardRef() cùng useRef() khiến cho component parent thao tác chỉnh sửa trực tiếp element bên trong child
-Sử dụng useImperativeHandle() giúp giới hạn các thao tác parent có thể sửa trên element của child component (~ tính đóng gói)

///////////////////////////////
    ParentComponent:
      const refComponent = useRef();
      // từ refComponent.current chỉ có thể gọi 1 số method useImperativeHandle() cho phép
      JSX: 
       <ChildComponent ref={refComponent} />
   
    ChildComponent:
      const ChildComponent = React.forwardRef((props, ref) => {
        const h1Ref = useRef();

        useImperativeHandle(ref, () => {
          change(value) {
            h1Ref.current.innerHTML = value;
          },
        })
         
        return (
          <h1 ref={h1Ref}>Hello</h1>
        )
      })

-useImperativeHandle(ref,{});
 - đối số thứ 1 truyền vào useImperativeHandle() là ref nhận được từ parent component
 - đối số thứ 2 là 1 object, object này chính là object ref.current ở parent component
   - đưa các funtion thực hiện sửa đổi element vào object giúp giới hạn các thao tác của parent với element đó
-dùng useRef() trong componet child tạo ra ref liên kết với element cho phép parent thao tác, không pulic hoàn toàn cho parent sử dụng
 











































